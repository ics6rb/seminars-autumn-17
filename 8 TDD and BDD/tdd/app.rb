# Веб-приложение на легковесном фреймворке Sinatra.

require 'sinatra'

# Sinatra - это легковесный фреймворк.
#
# Для того, чтобы он начал работать, достаточно одного Ruby-файла.
#
# В качестве контроллеров выступают функции, которые принимают блоки кода.
# В них описывается логика работы контроллера.
#
# Подробнее - http://sinatrarb.com/

# Регулярка для проверки того, что в строке есть только числа:
# начало строки - сколько угодно цифр - конец строки.
DIGIT_RE = /^\d+$/

# Индекс приложения - возвращает JSON с приветствием.
get '/' do
  # Задаем MIME-тип возвращаемого значения.
  content_type :json
  # Кастуем хэш в JSON.
  {message: 'Hello!'}.to_json
end

# Складывает два числа
get '/add' do
  # Задаем MIME-тип возвращаемого значения.
  content_type :json

  # Парсим параметры. Возможно несколько вариантов.
  #
  # Если к нам приходят нормальные параметры (то есть числа), они все равно внутри params будут строками.
  # Поэтому нам нужно сделать to_i. Это params[:a].to_i.
  #
  # Если вдруг параметра нет в хэше, то он вернет nil. nil.to_i == 0, то есть ничего не упадет, но это так себе,
  # ведь в таком случае мы должны вернуть сообщение об ошибке. Тогда перед тем, как скастовать к инту, проверим,
  # что параметр вообще есть. Это params[:a].nil?
  #
  # ПРИМЕЧАНИЕ
  # Пока рассмотрим более понятный вариант ифчика: params[:a].to_i if not params[:a].nil?
  #
  # Дальше мы обернем это дело в скобки и напишем так: (params[:a].to_i if not params[:a].nil?) || nil.
  # Это нужно для того, чтобы переменная а была ТОЧНО инициализирована. Если условие не выполняется, пишем туда nil.
  #
  # Если теперь мы попытаемся передать в качестве параметра не строчку, а например массив, то оно тупо упадет.
  # Поэтому добавим перехват исключения NoMethodError.
  #
  # Теперь все будет работать нормально, но не хватает одной детали: если мы вдруг передадим "плохую" строку,
  # например такую - 'fkkeoe023', то to_i также даст 0. Для того, чтобы этого избежать, добавим регулярное выражение,
  # которое будет проверять, что в строке только числа. Тогда условие надо дополнить как
  # if not params[:a].nil? and DIGIT_RE =~ params[:a], то есть ключ есть в хэше, а значение по ключу соответствует
  # регулярке - в нем только цифры.
  #
  # Хорошо? Не тут-то было, если передадим массив, то все опять упадет. Поэтому в блок перехвата исключений добавим
  # Type Error. Теперь-то все ок!
  #
  # И наконец, памятуя о том, что Ruby любит эстетов, попытаемся переделать if на unless (то есть if not). И вот тут
  # уже не все так просто - нужно немного вспомнить алгебру логики. Если было if A, то станет unless !A, потому что
  # unless A = if !A. Поэтому ко всему выражению if not params[:a].nil? and DIGIT_RE =~ params[:a] надо добавить not.
  #
  # По всем правилам алгебры логики:
  # not(not params[:a].nil? and DIGIT_RE =~ params[:a]) = params[:a].nil? OR DIGIT_RE !~ params[:a]
  #
  # Здесь !~ значит not(=~)
  begin
    a = (params[:a].to_i unless params[:a].nil? || DIGIT_RE !~ params[:a]) || nil
    b = (params[:b].to_i unless params[:b].nil? || DIGIT_RE !~ params[:b]) || nil
  rescue NoMethodError, TypeError
    a = nil
    b = nil
  end

  # Если хотя бы одна переменная имеет неверное значение, то ошибка
  if !a || !b
    {}.to_json
  else
    # В противном случае - сумма.
    {answer: a + b}.to_json
  end
end
